# OneCCLvars

## CCL_LOG_LEVEL


Set this environment variable to control logging level. 
        


The `CCL_LOG_LEVEL` environment variable can be set to control the level of detail in the logging output generated by the CCL library.
&quot;&lt;value&gt;&quot;: &quot;error&quot;, &quot;warn&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;trace&quot;
By-default: &quot;warn&quot; 
        

## CCL_WORKER_COUNT


Set specify the number of oneCCL worker threads. 
        


&quot;&lt;value&gt;&quot; - The number of worker threads for oneCCL rank
By-default: &quot;1&quot; 
        

## CCL_WORKER_AFFINITY


Set to specify cpu affinity for oneCCL worker threads. 
        


&quot;&lt;value&gt;&quot;: &quot;auto&quot;, &quot;&lt;cpulist&gt;&quot;: <br />
 &quot;auto&quot; - Workers are automatically pinned to last cores of pin domain. Pin domain depends from process launcher. If mpirun from oneCCL package is used then pin domain is MPI process pin domain. Otherwise, pin domain is all cores on the node. <br />
 &quot;&lt;cpulist&gt;&quot; - A comma-separated list of core numbers and/or ranges of core numbers for all local workers, one number per worker. The i-th local worker is pinned to the i-th core in the list. For example 'a','b'-'c'defines list of cores contaning core with number 'a' and range of cores with numbers from 'b' to 'c'. The number should not exceed the number of cores available on the system.
By-default: &quot;not-specified&quot; 
        

## CCL_WORKER_MEM_AFFINITY


Set to specify memory affinity for oneCCL worker threads. <br />
. 
        


&quot;&lt;nodelist&gt;&quot; : <br />
 &quot;auto&quot; - Workers are automatically pinned to NUMA nodes that correspond to CPU affinity of workers. <br />
 A comma-separated list of NUMA node numbers for all local workers, one number per worker. The i-th local worker is pinned to the i-th NUMA node in the list. The number should not exceed the number of NUMA nodes available on the system.
By-default: &quot;not-specified&quot; 
        

## CCL_ATL_SHM


Set this environment variable to enable the OFI shared memory provider for communication between ranks in the same node of host (CPU) buffers. <br />
. 
        


Syntax <br />
CCL_ATL_SHM=&quot;&lt;value&gt;&quot;<br />
<br />
Arguments<br />
&quot;&lt;value&gt;&quot; Description<br />

 - 0 Disables OFI shared memory provider (default).<br />


 - 1 Enables OFI shared memory provider.<br />
<br />
Description<br />
 Set this environment variable to enable the OFI shared memory provider for communication between ranks in the same node of host (CPU) buffers.



By-default: &quot;0&quot; 
        

## CCL_ALLGATHERV


Set allgatherv algorithm. 
        


ALLGATHERV algorithms
 - direct Based on MPI_Iallgatherv

 - naive Send to all, receive from all

 - ring Alltoall-based algorithm

 - flat Alltoall-based algorithm

 - multi_bcast Series of broadcast operations with different root ranks

 - topo Topo scaleup algorithm



By-default: &quot;topo&quot;, if sycl and l0 are enabled, otherwise &quot;naive&quot; for ofi or &quot;direct&quot; for mpi; &quot;ring&quot; used as fallback 
        

## CCL_ALLREDUCE


Set allreduce algorithm. 
        


ALLREDUCE algorithms
 - direct Based on MPI_Iallreduce

 - rabenseifner Rabenseifner&#8217;s algorithm

 - nreduce May be beneficial for imbalanced workloads

 - ring Reduce_scatter + allgather ring. Use CCL_RS_CHUNK_COUNT and CCL_RS_MIN_CHUNK_SIZE to control pipelining on reduce_scatter phase.

 - double_tree Double-tree algorithm

 - recursive_doubling Recursive doubling algorithm

 - 2d Two-dimensional algorithm (reduce_scatter + allreduce + allgather). Only available for Host (CPU) buffers.

 - topo Topo scaleup algorithm (available if sycl and l0 are enabled)



By-default: &quot;topo&quot;, if sycl and l0 are enable, otherwise &quot;ring&quot; 
        

## CCL_ALLTOALL


Set alltoall algorithm. 
        


ALLTOALLV algorithms
 - direct Based on MPI_Ialltoallv

 - naive Send to all, receive from all

 - scatter Scatter-based algorithm

 - topo Topo scaleup algorithm (available if sycl and l0 are enabled)



By-default: &quot;topo&quot;, if sycl and l0 are enable, otherwise &quot;scatter&quot; 
        

## CCL_ALLTOALLV


Set alltoallv algorithm. 
        


ALLTOALLV algorithms
 - direct Based on MPI_Ialltoallv

 - naive Send to all, receive from all

 - topo Topo scaleup algorithm (available if sycl and l0 are enabled)



By-default: &quot;topo&quot;, if sycl and l0 are enable, otherwise &quot;scatter&quot; 
        

## CCL_BARRIER


Set barrier algorithm. 
        


BARRIER algorithms
 - direct Based on MPI_Ibarrier

 - ring Ring-based algorithm



Note: BARRIER does not support the CCL_BARRIER_SCALEOUT environment variable. To change the algorithm for scaleout, use CCL_BARRIER.
By-default: &quot;direct&quot; 
        

## CCL_BCAST


Set broadcast algorithm. 
        


BCAST algorithms
 - direc Based on MPI_Ibcast

 - ring Ring

 - double_tree Double-tree algorithm

 - naive Send to all from root rank



Note: BCAST algorithm does not support yet the CCL_BCAST_SCALEOUT environment variable. To change the algorithm for BCAST, use CCL_BCAST.
By-default: &quot;direct&quot; 
        

## CCL_REDUCE


Set reduce algorithm. 
        


REDUCE algorithms
 - direct Based on MPI_Ireduce

 - rabenseifner Rabenseifner&#8217;s algorithm

 - ring Ring algorithm

 - tree Tree algorithm

 - double_tree Double-tree algorithm

 - topo Topo scaleup algorithm (available if sycl and l0 are enabled)



By-default: &quot;topo&quot; if sycl and l0 are enabled, otherwise tree for ofi transport or direct for mpi 
        

## CCL_REDUCE_SCATTER


Set reduce-scatter algorithm. 
        


REDUCE_SCATTER algorithms
 - direct Based on MPI_Ireduce_scatter_block

 - ring Use CCL_RS_CHUNK_COUNT and CCL_RS_MIN_CHUNK_SIZE to control pipelining.

 - topo Topo algorithm (available if sycl and l0 are enabled, scaleup only)



Note: REDUCE_SCATTER algorithm does not support yet the CCL_REDUCE_SCATTER_SCALEOUT environment variable. To change the algorithm for REDUCE_SCATTER scaleout, use CCL_REDUCE_SCATTER.
By-default: &quot;direct&quot; 
        

## CCL_RECV


Set recv algorithm. 
        


RECV algorithms
 - direct Using prepost(d2h-h2d) copies to get host buffers to invoke mpi/ofi-&gt;recv()

 - topo Topo scale-up algorithm (available if sycl and l0 are enabled)

 - offload Using device buffers directly into mpi/ofi layer skipping prepost copies d2h h2d. By-default used for scale-out. Setting extra MPI env vars for getting better performance (available if sycl and l0 are enabled)



By-default: &quot;topo&quot; if sycl and l0 are enabled, otherwise offload for ofi/mpi transport 
        

## CCL_SEND


Set send algorithm. 
        


SEND algorithms
 - direct Using prepost(d2h-h2d) copies to get host buffers to invoke mpi/ofi-&gt;send()

 - topo Topo scale-up algorithm (available if sycl and l0 are enabled)

 - offload Using device buffers directly into mpi/ofi layer skipping prepost copies d2h h2d. By-default used for scale-out. Setting extra MPI env vars for getting better performance (available if sycl and l0 are enabled)



By-default: &quot;topo&quot; if sycl and l0 are enabled, otherwise offload for ofi/mpi transport 
        

## CCL_ALLGATHERV_SCALEOUT


Set scaleout allgatherv algorithm. 
        


ALLGATHERV algorithms
 - direct Based on MPI_Iallgatherv

 - naive Send to all, receive from all

 - ring Alltoall-based algorithm

 - flat Alltoall-based algorithm

 - multi_bcast Series of broadcast operations with different root ranks



By-default: &quot;naive&quot; for ofi or &quot;direct&quot; for mpi; &quot;ring&quot; used as fallback 
        

## CCL_ALLREDUCE_SCALEOUT


Set allreduce scaleout algorithm. 
        


ALLREDUCE algorithms
 - direct Based on MPI_Iallreduce

 - rabenseifner Rabenseifner&#8217;s algorithm

 - nreduce May be beneficial for imbalanced workloads

 - ring Reduce_scatter + allgather ring. Use CCL_RS_CHUNK_COUNT and CCL_RS_MIN_CHUNK_SIZE to control pipelining on reduce_scatter phase.

 - double_tree Double-tree algorithm

 - recursive_doubling Recursive doubling algorithm

 - 2d Two-dimensional algorithm (reduce_scatter + allreduce + allgather). Only available for Host (CPU) buffers.



By-default: &quot;ring&quot; 
        

## CCL_ALLTOALL_SCALEOUT


Set alltoall scaleout algorithm. 
        


ALLTOALL algorithms
 - direct Based on MPI_Ialltoall

 - naive Send to all, receive from all

 - scatter Scatter-based algorithm



By-default: &quot;scatter&quot; 
        

## CCL_ALLTOALLV_SCALEOUT


Set alltoallv scaleout algorithm. 
        


ALLTOALLV algorithms
 - direct Based on MPI_Ialltoallv

 - naive Send to all, receive from all

 - scatter Scatter-based algorithm



By-default: &quot;scatter&quot; 
        

## CCL_REDUCE_SCALEOUT


Set reduce scaleout algorithm. 
        


REDUCE algorithms
 - direct Based on MPI_Ireduce

 - rabenseifner Rabenseifner&#8217;s algorithm

 - ring Ring algorithm

 - tree Tree algorithm

 - double_tree Double-tree algorithm



By-default: &quot;double_tree&quot; 
        

## CCL_RS_CHUNK_COUNT


Set to specify maximum number of chunks for reduce_scatter phase in ring allreduce. 
        


&quot;&lt;count&gt;&quot; - Maximum number of chunks for reduce_scatter phase in ring allreduce
By-default: &quot;1&quot; 
        

## CCL_RS_MIN_CHUNK_SIZE


Set to specify minimum number of bytes in chunk for reduce_scatter phase in ring allreduce. 
        


&quot;&lt;size&gt;&quot; - Minimum number of bytes in chunk for reduce_scatter phase in ring allreduce. Affects actual value of CCL_RS_CHUNK_COUNT.
By-default: &quot;65536&quot; 
        

## CCL_REDUCE_SCATTER_TOPO_READ


Set this environment variable to select read or write based device-to-device data copy during the reduce_scatter stage of Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers. 
        


Syntax CCL_REDUCE_SCATTER_TOPO_READ=&quot;&lt;value&gt;&quot;
Arguments
&quot;&lt;value&gt;&quot; Description
 - 1 Uses read based copy to transfer data across GPUs for the reduce_scatter stage of Allreduce, Reduce, and Reduce-Scatter collectives (default).

 - 0 Uses write based copy to transfer data across GPUs for the reduce_scatter stage of Allreduce, Reduce, and Reduce-Scatter collectives.



Description
Set this environment variable to select read or write based device-to-device data copy during the reduce_scatter stage of Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers.
By-default: &quot;1&quot; 
        

## CCL_REDUCE_SCATTER_MONOLITHIC_KERNEL


Set this environment variable to enable compute kernels for Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers. 
        


Syntax CCL_REDUCE_SCATTER_MONOLITHIC_KERNEL=&quot;&lt;value&gt;&quot;
Arguments
&quot;&lt;value&gt;&quot; Description
 - 1 Uses compute kernels to transfer data across GPUs for Allreduce, Reduce, and Reduce-Scatter collectives

 - 0 Uses copy engines to transfer data across GPUs for Allreduce, Reduce, and Reduce-Scatter collectives (default).



Description
Set this environment variable to enable compute kernels for Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers
By-default: &quot;0&quot; 
        

## CCL_ALLGATHERV_MONOLITHIC_PIPELINE_KERNEL


Set this environment variable to enable compute kernels for Allgather collectives using device (GPU) buffers. 
        


Syntax
CCL_ALLGATHERV_MONOLITHIC_PIPELINE_KERNEL=&quot;&lt;value&gt;&quot; Arguments
&quot;&lt;value&gt;&quot; Description
 - 1 Uses compute kernels to transfer data across GPUs for Allgather collective

 - 0 Uses copy engines to transfer data across GPUs for Allgather collectives (default)



Description
Set this environment variable to enable compute kernels for Allgather collectives using device (GPU) buffers
By-default: &quot;0&quot; 
        

## CCL_ALLTOALLV_MONOLITHIC_KERNEL


Set this environment variable to enable compute kernels for Alltoall and Alltoallv collectives using device (GPU) buffers. 
        


Syntax
CCL_ALLTOALLV_MONOLITHIC_KERNEL=&quot;&lt;value&gt;&quot;
Arguments
&quot;&lt;value&gt;&quot; Description
 - 1 Uses compute kernels to transfer data across GPUs for AlltoAll and Alltoallv collectives (default)

 - 0 Uses copy engines to transfer data across GPUs for AlltoAll and Alltoallv collectives



Description
Set this environment variable to enable compute kernels for Alltoall and Alltoallv collectives using device (GPU) buffers
By-default: &quot;1&quot; 
        

## CCL_ALLGATHERV_PIPE_CHUNK_COUNT


Set this environment variable to enable pipelining implementation for Allgatherv collectives using device (GPU) buffers. 
        


Syntax
CCL_ALLGATHERV_PIPE_CHUNK_COUNT=&quot;&lt;value&gt;&quot; Arguments
&quot;&lt;value&gt;&quot; Description
 - 0: (default) Bypasses the chunking/pipelining code and directly calls the topology-aware code

 - 1: Calls the pipelining code with a single chunk. Effectively, it has identical behavior and performance as with &quot;0&quot;, but exercises the chunking code path with a single chunk.



2 or higher: Divides the message into as many logical parts, or chunks, as specified. Then, it executes the collective with each logical chunk. This should allow for several phases of the algorithm to run in parallel, as long as they don't use the same physical resource. Effectively, this should increase performance.
Description
Set this environment variable to enable control how many chunks are used for Allgatherv, pipeline-based collectives using device (GPU) buffers.
By-default: &quot;0&quot; 
        

## CCL_ALLREDUCE_PIPE_CHUNK_COUNT


Set this environment variable to enable pipelining implementation for Allreduce collectives using device (GPU) buffers. 
        


Syntax
CCL_ALLREDUCE_PIPE_CHUNK_COUNT=&quot;&lt;value&gt;&quot; Arguments
&quot;&lt;value&gt;&quot; Description
 - 0: (default) Bypasses the chunking/pipelining code and directly calls the topology-aware code

 - 1: Calls the pipelining code with a single chunk. Effectively, it has identical behavior and performance as with &quot;0&quot;, but exercises the chunking code path with a single chunk.



2 or higher: Divides the message into as many logical parts, or chunks, as specified. Then, it executes the collective with each logical chunk. This should allow for several phases of the algorithm to run in parallel, as long as they don't use the same physical resource. Effectively, this should increase performance.
Description
Set this environment variable to enable control how many chunks are used for Allreduce pipeline-based collectives using device (GPU) buffers.
By-default: &quot;0&quot; 
        

## CCL_REDUCE_SCATTER_PIPE_CHUNK_COUNT


Set this environment variable to enable pipelining implementation for Reduce_Scatter collectives using device (GPU) buffers. 
        


Syntax
CCL_REDUCE_SCATTER_PIPE_CHUNK_COUNT=&quot;&lt;value&gt;&quot; Arguments
&quot;&lt;value&gt;&quot; Description
 - 0: (default) Bypasses the chunking/pipelining code and directly calls the topology-aware code

 - 1: Calls the pipelining code with a single chunk. Effectively, it has identical behavior and performance as with &quot;0&quot;, but exercises the chunking code path with a single chunk.



2 or higher: Divides the message into as many logical parts, or chunks, as specified. Then, it executes the collective with each logical chunk. This should allow for several phases of the algorithm to run in parallel, as long as they don't use the same physical resource. Effectively, this should increase performance.
Description
Set this environment variable to enable control how many chunks are used for Reduce_Scatter pipeline-based collectives using device (GPU) buffers.
By-default: &quot;0&quot; 
        

## CCL_REDUCE_PIPE_CHUNK_COUNT


Set this environment variable to enable pipelining implementation for Reduce collectives using device (GPU) buffers. 
        


Syntax
CCL_REDUCE_PIPE_CHUNK_COUNT=&quot;&lt;value&gt;&quot; Arguments
&quot;&lt;value&gt;&quot; Description
 - 0: (default) Bypasses the chunking/pipelining code and directly calls the topology-aware code

 - 1: Calls the pipelining code with a single chunk. Effectively, it has identical behavior and performance as with &quot;0&quot;, but exercises the chunking code path with a single chunk.



2 or higher: Divides the message into as many logical parts, or chunks, as specified. Then, it executes the collective with each logical chunk. This should allow for several phases of the algorithm to run in parallel, as long as they don't use the same physical resource. Effectively, this should increase performance.
Description
Set this environment variable to enable control how many chunks are used for Reduce pipeline-based collectives using device (GPU) buffers.
By-default: &quot;0&quot; 
        

## CCL_LOCAL_RANK


Set this environment variable to specify the rank number of the current process in the local host. 
        


Syntax
CCL_LOCAL_RANK=&quot;&lt;value&gt;&quot;
Arguments
&quot;&lt;value&gt;&quot; Description
 - RANK Rank number of the current process in the local host



Description
Set this environment variable to specify the rank number of the current process in the local host
By-default: N/A; job/process launcher (CCL_PROCESS_LAUNCHER) needs to be used if variable not specified 
        

## CCL_LOCAL_SIZE


Set this environment variable to specify the total number of ranks on the local host. 
        


Syntax
CCL_LOCAL_SIZE=&quot;&lt;value&gt;&quot;
Arguments
&quot;&lt;value&gt;&quot; Description
 - SIZE Total number of ranks on the local host.



Description
Set this environment variable to specify the total number of ranks on the local host
By-default: N/A; job/process launcher (CCL_PROCESS_LAUNCHER) needs to be used if variable not specified 
        

## CCL_PROCESS_LAUNCHER


Set this environment variable to specify the job launcher to use. 
        


Syntax
CCL_PROCESS_LAUNCHER=&quot;&lt;value&gt;&quot;
Arguments
&quot;&lt;value&gt;&quot; Description
 - hydra Uses the MPI hydra job launcher (default)

 - torch Uses torch job launcher

 - pmix It is used with the PALS job launcher which uses the pmix API, so your mpiexec command should look something like this: CCL_PROCESS_LAUNCHER=pmix CCL_ATL_TRANSPORT=mpi mpiexec -np 2 -ppn 2 &lt;ndash /&gt;pmi=pmix ...

 - none No Job launcher is used. In this case, the user needs to specify the values for CCL_LOCAL_SIZE and CCL_LOCAL_RANK



Description
Set this environment variable to specify the job launcher to use.
By-default: &quot;hydra&quot; 
        

## CCL_ZE_ENABLE_OVERSUBSCRIPTION_FALLBACK


Set to enable oversubscription in topo fallback stage for all collectives. 
        


This enviroment variable enables or disables the oversubscription fallback from topo algorithm to copy in/out
&quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot;
By-default: &quot;1&quot; 
        

## CCL_ZE_ENABLE_OVERSUBSCRIPTION_THROW


Set to enable oversubscription throw for all collectives. 
        


This enviroment variable enables or disables the oversubscription throw check
&quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot;
By-default: &quot;1&quot; 
        


    


    
# ExpOneCCLvars

## CCL_REDUCE_SCATTER_MONOLITHIC_PIPELINE_KERNEL


Set to specify monolithic pipeline approach for reduce_scatter phase in allreduceand reduce collectives. 
        


This enviroment variable has the advantage of forming a seamless pipeline that conceals the data transfer time across MDFI. This way, a process reads the data from its peer tile on the same GPU, performs the reduction, and writes to a temporary buffer located on a different GPU. This modification will cover the time for transferring the data through XeLinks during the reduce-scatter phase in allreduce and reduce collectives.
&quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot;
By-default: &quot;1&quot; 
        

## CCL_ZE_IPC_EXCHANGE


Set to specify the mechanism to use for Level Zero IPC exchange. 
        


<br />
 &quot;drmfd&quot; - Uses a the DRM mechanism for Level Zero IPC exchange. This is an experimental mechanism that is used with OS kernels previous to SP4. To use the DRM mechanism, the libdrm and drm headers must be available on a system. <br />
 &quot;pidfd&quot; - Uses pidfd mechanism for Level Zero IPC exchange. It requires OS kernel SP4 or above as it requires Linux 5.6 kernel or above <br />
 &quot;sockets&quot; - Uses socket mechanism for Level Zero IPC exchange. It is usually slower than the other two mechanisms, but can be used for debugging as it is usually available on most systems
&quot;&lt;value&gt;&quot;: &quot;drmfd&quot;, &quot;pidfd&quot;, &quot;sockets&quot;
By-default: &quot;drmfd&quot; 
        

## CCL_ZE_DRM_BDF_SUPPORT


Use bdf support for mapping logical to physical devices. 
        


To obtain the physical device id based on the bdf, we need get and then parse the bdf values. Then using those values we can identify the particular device by referencing the appropriate fields in a pci configuration space for pci devices.to utilize bdf for the purpose of mapping logical devices to their corresponding physical devices.
&quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot;
By-default: &quot;1&quot; 
        

## CCL_REDUCE_SCATTER_FALLBACK_ALGO


Use the fallback algorithm for reduce_scatter. 
        


The fallback algorithm performs a full allreduce and then copies a subset of its output to the recv buffer. Currently, the fallback algorithm is used for scaleout whereas scaleup uses optimized algorithm.
&quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot;
By-default: &quot;0&quot; 
        

## CCL_ZE_AUTO_TUNE_PORTS


Automatically tune algorithm protocols based on port count. 
        


Use number of ports to detect the 12 ports system and use write protocols on such systems for collectives. Users can disable this automatic detection and select the protocols manually.
&quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot;
By-default: &quot;1&quot; 
        

## CCL_ZE_PT2PT_READ


Enable switching of read and write protocols for pt2pt topo algorithm. 
        


Control pt2pt read/write protocols.<br />
 Read Protocol:<br />
 It means SEND side is exchanging the handle with RECV side. Then execute the copy operation on the RECV operation side, where the dst buf is the local buffer and the source buffer is the remote buffer.<br />
 Write Protocol:<br />
 it means RECV side is exchanging the handle with SEND side. Execute the copy operation on the SEND operation side, where the dst buf is the remote buffer and the source buffer is the local buffer. <br />
 &quot;&lt;value&gt;&quot; : &quot;0&quot;, &quot;1&quot; <br />
 By-default: &quot;1&quot; 
        

## CCL_ZE_TYPE2_TUNE_PORTS


Tunable value for collectives to adjust copy engine indexes. 
        


use 2,4,6 copy engine indexes for host with 6 ports for allreduce, reduce and allgatherv &quot;&lt;value&gt;&quot;: &quot;on&quot; - always use write mode with calculated indexes &quot;off&quot; - always disabled &quot;detected&quot; - determined by the logic in detection &quot;undetected&quot; - the default value, used before the logic in detection
By-default: &quot;undetected&quot; 
        

## CCL_BARRIER_SYNC


Switch ccl::barrier() host-sync / host-async options. 
        


Historically ccl::barrier() was always synchronous. That does not match with oneCCL asynchronous concept. Same as other collectives, ccl::barrier() should be host-asynchronous if possible. As it would be too much to change in one moment, we start through experimental variable which introduces the option to make barrier host-asynchronous. Use CCL_BARRIER_SYNC=0 to achieve that.
By-default: &quot;1 (SYNC)&quot; 
        


Experimental OneCCL Environment Variables Functionality of these variables has not been (fully) tested and, therefore, cannot be supported nor guaranteed. 
    


    
